data_type: metatranscriptome
experiment: jgi-metat
samples:
    H1000000:
        path:
            - /pic/projects/mint/hofmockel/data/jgi/Hofmockel_1000000-3_ISU_MetaT/Metatranscriptome_Filtered_Data/9371.2.130814.GTTTCG.anqtp.hR.fastq.gz
        # 'interleaved' or 'paired-end'
        scheme: interleaved
        type: metatranscriptome
        # phred: 33
    H1000008:
        path:
            - /pic/projects/mint/hofmockel/data/jgi/Hofmockel_1000008-3_ISU_MetaT/Metatranscriptome_Filtered_Data/9371.2.130814.CGTACG.anqtp.hR.fastq.gz
        scheme: interleaved
        type: metatranscriptome
    H1000040:
        path:
            - /pic/projects/mint/hofmockel/data/jgi/Hofmockel_1000040-3_ISU_MetaT/Metatranscriptome_Filtered_Data/9371.2.130814.GAGTGG.anqtp.hR.fastq.gz
        scheme: interleaved
        type: metatranscriptome
    H1000044:
        path:
            - /pic/projects/mint/hofmockel/data/jgi/Hofmockel_1000044-3_ISU_MetaT/Metatranscriptome_Filtered_Data/9528.1.136365.ATCACG.anqtp.hR.fastq.gz
        scheme: interleaved
        type: metatranscriptome
    H1000056:
        path:
            - /pic/projects/mint/hofmockel/data/jgi/Hofmockel_1000056-3_ISU_MetaT/Metatranscriptome_Filtered_Data/9371.3.130821.ACTGAT.anqtp.hR.fastq.gz
        scheme: interleaved
        type: metatranscriptome
    H1000060:
        path:
            - /pic/projects/mint/hofmockel/data/jgi/Hofmockel_1000060-3_ISU_MetaT/Metatranscriptome_Filtered_Data/9371.3.130821.ATTCCT.anqtp.hR.fastq.gz
        scheme: interleaved
        type: metatranscriptome
    H1000068:
        path:
            - /pic/projects/mint/hofmockel/data/jgi/Hofmockel_1000068-3_ISU_MetaT/Metatranscriptome_Filtered_Data/9371.1.130807.ATCACG.anqtp.hR.fastq.gz
        scheme: interleaved
        type: metatranscriptome
    H1000072:
        path:
            - /pic/projects/mint/hofmockel/data/jgi/Hofmockel_1000072-3_ISU_MetaT/Metatranscriptome_Filtered_Data/9371.1.130807.CGATGT.anqtp.hR.fastq.gz
        scheme: interleaved
        type: metatranscriptome
    H1000076:
        path:
            - /pic/projects/mint/hofmockel/data/jgi/Hofmockel_1000076-3_ISU_MetaT/Metatranscriptome_Filtered_Data/9371.1.130807.TTAGGC.anqtp.hR.fastq.gz
        scheme: interleaved
        type: metatranscriptome
    H1000120:
        path:
            - /pic/projects/mint/hofmockel/data/jgi/Hofmockel_1000120-3_ISU_MetaT/Metatranscriptome_Filtered_Data/9371.1.130807.TGACCA.anqtp.hR.fastq.gz
        scheme: interleaved
        type: metatranscriptome
    H1000124:
        path:
            - /pic/projects/mint/hofmockel/data/jgi/Hofmockel_1000124-3_ISU_MetaT/Metatranscriptome_Filtered_Data/9528.1.136365.CGATGT.anqtp.hR.fastq.gz
        scheme: interleaved
        type: metatranscriptome
    H1000132:
        path:
            - /pic/projects/mint/hofmockel/data/jgi/Hofmockel_1000132-3_ISU_MetaT/Metatranscriptome_Filtered_Data/9371.1.130807.ACAGTG.anqtp.hR.fastq.gz
        scheme: interleaved
        type: metatranscriptome
    H1000136:
        path:
            - /pic/projects/mint/hofmockel/data/jgi/Hofmockel_1000136-3_ISU_MetaT/Metatranscriptome_Filtered_Data/9371.1.130807.GCCAAT.anqtp.hR.fastq.gz
        scheme: interleaved
        type: metatranscriptome
    H1000180:
        path:
            - /pic/projects/mint/hofmockel/data/jgi/Hofmockel_1000180-3_ISU_MetaT/Metatranscriptome_Filtered_Data/9528.1.136365.TTAGGC.anqtp.hR.fastq.gz
        scheme: interleaved
        type: metatranscriptome
    H1000188:
        path:
            - /pic/projects/mint/hofmockel/data/jgi/Hofmockel_1000188-3_ISU_MetaT/Metatranscriptome_Filtered_Data/9371.2.130814.CAGATC.anqtp.hR.fastq.gz
        scheme: interleaved
        type: metatranscriptome
    H1000192:
        path:
            - /pic/projects/mint/hofmockel/data/jgi/Hofmockel_1000192-3_ISU_MetaT/Metatranscriptome_Filtered_Data/9371.2.130814.ACTTGA.anqtp.hR.fastq.gz
        scheme: interleaved
        type: metatranscriptome
    H1000196:
        path:
            - /pic/projects/mint/hofmockel/data/jgi/Hofmockel_1000196-3_ISU_MetaT/Metatranscriptome_Filtered_Data/9371.2.130814.GATCAG.anqtp.hR.fastq.gz
        scheme: interleaved
        type: metatranscriptome

# sliding_window OR expected_error
qual_method: sliding_window
temporary_directory: /scratch
minimum_read_count_to_analyze: 200
threads: 23
# shell command prefix
prefix: "srun --exclusive -N1 -n1 -c"
filtering:
    first_pass:
        # fastas to parse into kmers which are then trimmed from the sequences
        adapters: ref/adapters.fa.gz
        # Look for shorter kmers at read tips down to this length; 0 disables
        mink: 8
        minimum_base_quality: 10
        # kmer mismatches allowed during adapter trim process
        allowable_kmer_mismatches: 1
        # length of kmer to search against sequences
        reference_kmer_match_length: 31
        # passing single-end read length, prior to merging
        minimum_passing_read_length: 51
        # Discard reads with a minimum base frequency below this
        min_base_frequency: 0.05
    second_pass:
        ## Optional VSEARCH MAX EE filter
        # after merging; the allowable limit of erroneous bases; accepts fractions as well
        maximum_expected_error: 5
        # maximum number of N's for FASTQ filter
        maxns: 5
        ## TRIMMOMATIC quality trimming/filtering
        adapters: ref/adapters.fa.gz
        # adapter mismatch, palindrome clip threshold, and simple clip threshold (the values are nonsensical), e.g. 2:30:10
        adapter_clip: "2:30:10"
        # Cut bases off the start of a read, if below this quality
        leading: 15
        # Cut bases off the end of a read, if below this quality
        trailing: 15
        # specifies the number of bases to average across and required quality, e.g. 4:15
        window_size_quality: "8:25"
        # The number of bases to keep, from the start of the read; 0 disables
        crop: 0
        # The number of bases to remove from the start of the read; 0 disables
        headcrop: 0
        # passing read length after quality trimming merged reads
        minimum_passing_read_length: 51
    contamination:
        references:
            # this key ('rRNA') is required
            rRNA: databases/contaminant/silva_rfam_all_rRNAs.fa
            phiX: databases/contaminant/phiX174_virus.fa
        # Don't look for indels longer than this
        maxindel: 20
        # Fraction of max alignment score required to keep a site
        minratio: 0.65
        # mapping kmer length; range 8-15; longer is faster but uses more memory; shorter is more sensitive
        k: 12
        # Minimum number of seed hits required for candidate sites
        minhits: 1
        # Set behavior on ambiguously-mapped reads (with multiple top-scoring mapping locations):
        #   best    (use the first best site)
        #   toss    (consider unmapped)
        #   random  (select one top-scoring site randomly)
        #   all     (retain all top-scoring sites)
        ambiguous: best

merging:
    minimum_overlap: 30
    maximum_overlap: 220
    maximum_mismatch_density: 0.25

assembly:
    # fraction of the machine's total memory or bytes
    memory: 0.99
    # minimum multiplicity for filtering (k_min+1)-mers
    minimum_count: 2
    # minimum kmer size (<= 255), must be odd number
    kmer_min: 21
    # maximum kmer size (<= 255), must be odd number
    kmer_max: 121
    # increment of kmer size of each iteration (<= 28), must be even number
    kmer_step: 20
    # merge complex bubbles of length <= l*kmer_size and similarity >= s
    merge_level: 20,0.98
    # strength of low depth pruning (0-3)
    prune_level: 2
    # ratio threshold to define low local coverage contigs
    low_local_ratio: 0.2
    # minimum length of contigs to output from the assembler; can be filtered
    # downstream using minl
    minimum_contig_length: 200
    # Discard contigs with lower average coverage.
    minc: 5
    # Discard contigs with a lower percent covered bases.
    minp: 40
    # Discard contigs with fewer mapped reads.
    minr: 0
    # Discard contigs shorter than this (after trimming).
    minl: 250
    # Trim the first and last X bases of each sequence.
    trim: 0

annotation:
    ## ORFs
    # https://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi
    translation_table: 11
    # when counting reads aligning to ORFs, require at least this many bp
    # overlapping the ORF
    minimum_overlap: 20

    references:
        # arbitrary name for each reference
        eggnog:
            # non-tree based reference requires namemap database and fasta
            namemap: /pic/projects/mint/atlas_databases/functional/eggnog/eggnog4_nonredundant.db
            fasta: /pic/projects/mint/atlas_databases/functional/eggnog/eggnog4_nonredundant.fasta
            # number of entries per FASTA to be aligned with DIAMOND
            chunk_size: 250000
            # 'fast' or 'sensitive'
            run_mode: fast
            # setting top_seqs to 5 will report all alignments whose score is
            # at most 5% lower than the top alignment score for a query
            top_seqs: 5
            # maximum e-value to report alignments
            e_value: "0.000001"
            # minimum identity % to report an alignment
            min_identity: 50
            # minimum query cover % to report an alignment
            query_coverage: 60
            # gap open penalty
            gap_open: 11
            # gap extension penalty
            gap_extend: 1
            # Block size in billions of sequence letters to be processed at a time.
            # This is the main parameter for controlling DIAMOND's memory usage.
            # Bigger numbers will increase the use of memory and temporary disk space,
            # but also improve performance. The program can be expected to roughly use
            # six times this number of memory (in GB).
            block_size: 4
            # The number of chunks for processing the seed index (default=4). This
            # option can be additionally used to tune the performance. It is
            # recommended to set this to 1 on a high memory server, which will
            # increase performance and memory usage, but not the usage of temporary
            # disk space.
            index_chunks: 4
            # 'majority' or 'best'; summary method for annotating ORFs
            summary_method: best
            # minimum allowable BLAST alignment length
            min_length: 60
            # maximum allowable e-value of BLAST hit when parsing DIAMOND hits
            max_evalue: 0.000001
            # maximum number of BLAST hits to consider when summarizing ORFs
            max_hits: 10
            # filters ORF BLAST hits by only keep hits within this fraction of
            # the highest bitscore; this is recommended over max_hits
            top_fraction: 0.50
            # minimum allowable BLAST alignment bitscore; 0 effectively disables
            min_bitscore: 0
        refseq:
            # tree based reference requires namemap database, tree, and fasta
            namemap: /pic/projects/mint/atlas_databases/functional/refseq/refseq78.complete.nonredundant_protein.faa.db
            tree: /pic/projects/mint/atlas_databases/functional/refseq/refseq78.complete.nonredundant_protein.faa.tree
            fasta: /pic/projects/mint/atlas_databases/functional/refseq/refseq78.complete.nonredundant_protein.faa
            # number of entries per FASTA to be aligned with DIAMOND
            chunk_size: 250000
            run_mode: fast
            top_seqs: 5
            e_value: "0.000001"
            min_identity: 50
            query_coverage: 60
            gap_open: 11
            gap_extend: 1
            block_size: 6
            index_chunks: 1
            # 'lca', 'majority', or 'best'; summary method for annotating ORFs; when
            # using LCA, it's recommended that one limits the number of hits using a
            # low top_fraction
            summary_method: best
            # 'lca', 'lca-majority', or 'majority'; summary method for aggregating ORF
            # taxonomic assignments to contig level assignment; 'lca' will result in
            # most stringent, least specific assignments
            aggregation_method: lca-majority
            # constitutes a majority fraction at tree node for 'lca-majority' ORF
            # aggregation method
            majority_threshold: 0.51
            # minimum allowable BLAST alignment length
            min_length: 60
            # maximum allowable e-value of BLAST hit
            max_evalue: 0.000001
            # maximum number of BLAST hits to consider when summarizing ORFs; can
            # drastically alter ORF LCA assignments if too high without further limits
            max_hits: 10
            top_fraction: 0.50

binning:
    minimum_contig_length: 1000
    # iterations of Expectation-Maximization algorithm
    maximum_iterations: 50
    # probability threshold for EM final classification
    probability_threshold: 0.9
    # By default MaxBin will look for 107 marker genes present in >95% of bacteria.
    # Alternatively you can also choose 40 marker gene sets that are universal
    # among bacteria and archaea (Wu et al., PLoS ONE 2013). This option may
    # be better suited for environment dominated by archaea; however it tends
    # to split genomes into more bins.
    marker_set: 107

summary_counts:
    # Possible columns table column values upon which to aggregate:
        # contig, orf, taxonomy, orf_taxonomy, refseq_product, uniprot_ac
        # eggnog_ssid_b, eggnog_species_id, uniprot_id, cog_func_id, cog_id,
        # cog_product, cog_level1_code, cog_level1_name, cog_level2_name,
        # cazy_id1, cazy_id2, cazy_class, cazy_clan, cazy_product, cazy_gene_id,
        # cazy_taxa, cazy_ec, ko_id, ko_level1_name, ko_level2_name, ko_level3_id,
        # ko_level3_name, ko_gene_symbol, ko_product, ko_ec

    # this is a special case to allow for taxon level specification
    taxonomy:
        # limit taxonomy in classification to the depth specified
        # possible values: kingdom, domain, phylum, class, order, family, genus, species
        # all levels if omitted
        levels:
            - phylum
            - class
            - order
            - species
        # tables to generate at these taxonomic levels
        KO:
            - ko_id
            - ko_ec
        COG:
            - cog_id
        CAZY:
            - cazy_id1
            - cazy_ec
    KO:
        - ko_id
        - ko_gene_symbol
        - ko_product
        - ko_ec
    KO_lvl1:
        - ko_level1_name
    KO_lvl2:
        - ko_level2_name
    KO_lvl3:
        - ko_level3_name
    EC:
        - ko_ec
    COG:
        - cog_id
        - cog_product
    COG_lvl1:
        - cog_level1_name
        - cog_level2_name
    Uniprot:
        - uniprot_ac
        - cazy_id1
        - cazy_class
        - cazy_product
        - cazy_ec
        - cazy_gene_id
        - cazy_taxa
